# 数据流程设计

## 一、钱包导入流程

```
用户输入地址
    ↓
地址格式验证
    ↓
检查是否已存在
    ↓
调用 HyperLiquid API
    ↓
获取历史交易数据
    ↓
计算基础指标
    ↓
生成钱包数据文件
    ↓
加入更新队列
    ↓
返回导入结果
```

### 1.1 批量导入流程

```
用户上传文件/粘贴地址列表
    ↓
解析地址列表（去重、验证）
    ↓
创建导入任务（加入队列）
    ↓
后台异步处理：
  ├─ 分批处理（每批100个）
  ├─ 并发控制（最多10个并发）
  ├─ 失败重试（最多3次）
  └─ 记录进度
    ↓
实时更新进度（WebSocket/轮询）
    ↓
完成导入，返回结果统计
```

---

## 二、数据更新流程

### 2.1 定时更新流程

```
定时任务触发（APScheduler）
    ↓
获取钱包列表（按优先级排序）
    ↓
分类处理：
  ├─ 活跃钱包（1小时更新）
  ├─ 普通钱包（6小时更新）
  └─ 休眠钱包（24小时更新）
    ↓
检查缓存（是否在5分钟内更新过）
    ↓
调用 HyperLiquid API（获取最新数据）
    ↓
增量更新（只处理新交易）
    ↓
重新计算指标
    ↓
更新钱包数据文件
    ↓
记录更新日志
```

### 2.2 手动刷新流程

```
用户点击刷新按钮
    ↓
前端发送刷新请求
    ↓
后端立即调用 API（忽略缓存）
    ↓
获取最新数据
    ↓
增量更新
    ↓
重新计算指标
    ↓
返回更新结果
    ↓
前端更新显示
```

---

## 三、数据分析流程

### 3.1 指标计算流程

```
加载钱包交易数据
    ↓
计算基础指标：
  ├─ 总盈亏（累计）
  ├─ ROI（收益率）
  ├─ 胜率（盈利交易/总交易）
  └─ 盈亏比（平均盈利/平均亏损）
    ↓
计算风险指标：
  ├─ 最大回撤（MDD）
  ├─ 波动率（标准差）
  └─ Sharpe 比率
    ↓
分析行为模式：
  ├─ 交易频率
  ├─ 持仓周期
  ├─ 多空偏好
  └─ 币种偏好
    ↓
生成标签（基于指标）
    ↓
计算 Smart Money Score
    ↓
保存计算结果（缓存）
```

### 3.2 收益曲线生成流程

```
获取钱包所有交易记录
    ↓
按时间排序
    ↓
计算每个时间点的余额：
  ├─ 初始余额
  ├─ 累计盈亏
  └─ 当前余额
    ↓
生成不同时间段的曲线：
  ├─ 24小时（每小时一个点）
  ├─ 7天（每6小时一个点）
  ├─ 30天（每天一个点）
  └─ 全部（每周一个点）
    ↓
存储曲线数据
```

---

## 四、推荐算法流程

```
加载所有钱包数据
    ↓
应用推荐筛选条件：
  ├─ 钱包年龄：1-6个月
  ├─ ROI > 200%
  ├─ 盈亏比 > 2.0
  ├─ 最大回撤 < 40%
  ├─ 本金 < $2000
  ├─ 胜率 > 55%
  └─ Smart Money Score > 70
    ↓
按 Smart Money Score 排序
    ↓
取 Top N（默认20）
    ↓
生成推荐理由：
  ├─ 高ROI + 低回撤
  ├─ 高胜率 + 高盈亏比
  └─ 小资金高效率
    ↓
返回推荐列表
```

---

## 五、API 调用流程

### 5.1 API 调用策略

```
检查缓存（5分钟内）
    ↓
缓存命中？
  ├─ 是 → 返回缓存数据
  └─ 否 → 继续
    ↓
检查限流（每秒最多10个请求）
    ↓
发送 API 请求
    ↓
请求成功？
  ├─ 是 → 缓存结果，返回数据
  └─ 否 → 错误处理
    ↓
错误处理：
  ├─ 网络错误 → 重试（最多3次，指数退避）
  ├─ API 限流 → 等待后重试
  └─ 其他错误 → 记录日志，返回错误
```

### 5.2 批量 API 调用优化

```
地址列表
    ↓
分批处理（每批100个）
    ↓
并发控制（信号量，最多10个并发）
    ↓
异步调用 API
    ↓
收集结果：
  ├─ 成功结果
  ├─ 失败结果（记录错误）
  └─ 限流结果（加入重试队列）
    ↓
处理重试队列（延迟后重试）
    ↓
返回最终结果
```

---

## 六、数据查询流程

### 6.1 钱包列表查询

```
前端请求（带筛选条件）
    ↓
加载钱包索引文件（index.json）
    ↓
应用筛选条件：
  ├─ 时间范围筛选
  ├─ ROI 范围筛选
  ├─ 胜率筛选
  └─ 其他条件筛选
    ↓
应用排序（按指定字段）
    ↓
分页处理（只返回当前页数据）
    ↓
加载完整钱包数据（按需）
    ↓
返回结果
```

### 6.2 钱包详情查询

```
前端请求钱包地址
    ↓
检查缓存（计算结果缓存）
    ↓
缓存命中？
  ├─ 是 → 返回缓存数据
  └─ 否 → 继续
    ↓
加载钱包数据文件
    ↓
检查数据新鲜度（是否需要更新）
    ↓
需要更新？
  ├─ 是 → 触发后台更新（异步）
  └─ 否 → 继续
    ↓
返回钱包数据
```

---

## 七、错误处理流程

### 7.1 API 调用错误

```
API 调用失败
    ↓
判断错误类型：
  ├─ 网络超时 → 重试（最多3次）
  ├─ API 限流 → 等待后重试
  ├─ 地址无效 → 记录错误，跳过
  └─ 其他错误 → 记录日志
    ↓
重试机制：
  ├─ 第1次：立即重试
  ├─ 第2次：等待1秒后重试
  └─ 第3次：等待3秒后重试
    ↓
仍然失败？
  ├─ 是 → 标记钱包为"更新失败"，记录错误
  └─ 否 → 继续处理
```

### 7.2 数据计算错误

```
计算指标时出错
    ↓
捕获异常
    ↓
记录错误日志（包含上下文）
    ↓
使用默认值或跳过该指标
    ↓
继续处理其他指标
    ↓
返回部分结果（标记哪些指标失败）
```

---

## 八、缓存策略流程

### 8.1 API 响应缓存

```
API 请求
    ↓
生成缓存 Key（地址 + 请求类型）
    ↓
检查缓存文件
    ↓
缓存存在且未过期（5分钟）？
  ├─ 是 → 返回缓存数据
  └─ 否 → 调用 API
    ↓
API 调用成功
    ↓
保存到缓存文件
    ↓
返回数据
```

### 8.2 计算结果缓存

```
需要计算指标
    ↓
生成缓存 Key（地址 + 数据版本）
    ↓
检查计算结果缓存
    ↓
缓存存在且数据未更新？
  ├─ 是 → 返回缓存结果
  └─ 否 → 重新计算
    ↓
计算结果
    ↓
保存到缓存
    ↓
返回结果
```

---

## 九、日志记录流程

### 9.1 操作日志

```
用户操作（导入/删除/刷新）
    ↓
记录操作日志：
  ├─ 时间戳
  ├─ 用户操作
  ├─ 钱包地址
  └─ 操作结果
    ↓
写入日志文件（app.log）
    ↓
日志轮转检查（文件大小/时间）
    ↓
需要轮转？
  ├─ 是 → 归档旧日志，创建新日志
  └─ 否 → 继续
```

### 9.2 API 调用日志

```
API 调用
    ↓
记录请求日志：
  ├─ 时间戳
  ├─ API 地址
  ├─ 请求参数
  └─ 响应状态
    ↓
写入 API 日志（api.log）
    ↓
记录性能指标（响应时间）
    ↓
慢查询检查（> 1秒）
    ↓
慢查询？
  ├─ 是 → 记录到性能日志
  └─ 否 → 继续
```

---

## 十、数据备份流程

### 10.1 自动备份

```
定时任务（每天凌晨2点）
    ↓
创建备份目录（带时间戳）
    ↓
备份数据文件：
  ├─ wallets/ 目录
  ├─ config/ 目录
  └─ index.json
    ↓
压缩备份文件
    ↓
清理旧备份（保留最近7天）
    ↓
记录备份日志
```

### 10.2 手动备份

```
用户触发备份
    ↓
选择备份范围：
  ├─ 全部数据
  ├─ 指定钱包
  └─ 配置文件
    ↓
创建备份
    ↓
下载备份文件（或保存到指定位置）
    ↓
返回备份结果
```

---

## 十一、性能优化流程

### 11.1 批量导入优化

```
批量地址列表
    ↓
预处理：
  ├─ 去重
  ├─ 格式验证
  └─ 检查已存在
    ↓
创建任务队列
    ↓
后台处理：
  ├─ 分批处理（100个/批）
  ├─ 并发控制（10个并发）
  ├─ 进度更新
  └─ 错误处理
    ↓
实时反馈进度（WebSocket/轮询）
    ↓
完成处理，返回统计
```

### 11.2 列表查询优化

```
查询请求
    ↓
检查索引文件（轻量级）
    ↓
应用筛选（在索引中筛选）
    ↓
获取符合条件的地址列表
    ↓
分页处理（只加载当前页）
    ↓
按需加载完整数据（懒加载）
    ↓
返回结果
```

---

## 十二、数据一致性保证

### 12.1 文件写入锁

```
需要写入文件
    ↓
获取文件锁（flock）
    ↓
锁获取成功？
  ├─ 是 → 写入文件 → 释放锁
  └─ 否 → 等待或重试
    ↓
写入完成
    ↓
释放文件锁
```

### 12.2 增量更新保证

```
更新钱包数据
    ↓
读取现有数据
    ↓
获取最新交易（基于时间戳）
    ↓
合并数据（去重）
    ↓
重新计算指标（基于完整数据）
    ↓
原子性写入（临时文件 + 重命名）
    ↓
更新索引文件
```

---

## 总结

以上流程设计确保了：

1. ✅ **数据准确性**：增量更新，避免重复
2. ✅ **性能优化**：缓存、分批、并发控制
3. ✅ **错误处理**：完善的错误处理和重试机制
4. ✅ **用户体验**：实时反馈，快速响应
5. ✅ **可维护性**：清晰的日志，易于排查问题

